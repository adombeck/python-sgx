#!/usr/bin/env python3-sgx

import logging
import os
from contextlib import contextmanager

from sgx import config

# noinspection PyBroadException
try:
    from sgx.trusted import sealing
except:
    logging.exception('')
    exit()

MANIFEST_PATH = os.path.join(config.CONFIG_DIR, 'sealing_manifest')

# XXX: Implement replay protection (not implemented in SDK yet)


class PersistentFileNotFoundError(Exception):
    pass


@contextmanager
def handle_sealing(manifest_path):
    unseal(manifest_path)
    yield
    seal(manifest_path)


def get_manifest_entries(manifest_path):
    with open(manifest_path) as manifest:
        lines = manifest.readlines()
        for line in lines:
            if line.startswith("#"):
                # It's a comment
                continue
            yield line.split()


def unseal(manifest_path):
    for type_, persistent_path, ephemeral_path in get_manifest_entries(manifest_path):
        if type_ == "d" and not os.path.isdir(persistent_path):
            os.mkdir(persistent_path)

        try:
            unseal_mapping(persistent_path, ephemeral_path)
        except PersistentFileNotFoundError:
            create_empty(persistent_path)
            create_empty(ephemeral_path)


def unseal_mapping(persistent_path, ephemeral_path):
    if os.path.isdir(persistent_path):
        unseal_directory(ephemeral_path, persistent_path)
    else:
        unseal_file(ephemeral_path, persistent_path)


def unseal_directory(ephemeral_path, persistent_path):
    try:
        os.mkdir(ephemeral_path)
    except FileExistsError:
        pass
    for entry in os.listdir(persistent_path):
        new_persistent_path = os.path.join(persistent_path, entry)
        new_ephemeral_path = os.path.join(ephemeral_path, entry)
        unseal_mapping(new_persistent_path, new_ephemeral_path)


def unseal_file(ephemeral_path, persistent_path):
    try:
        with open(persistent_path, 'br') as source:
            data = source.read()
    except FileNotFoundError:
        raise PersistentFileNotFoundError

    if data:
        secret, plain_text = sealing.unseal(data)
    else:
        secret = bytes()

    with open(ephemeral_path, 'bw') as dest:
        dest.write(secret)


def create_empty(path):
    open(path, 'bw').close()


def seal(manifest_path):
    for type_, persistent_path, ephemeral_path in get_manifest_entries(manifest_path):
        seal_mapping(persistent_path, ephemeral_path)
        check_if_deleted(persistent_path, ephemeral_path)


def seal_mapping(persistent_path, ephemeral_path):
    if os.path.isdir(ephemeral_path):
        seal_directory(ephemeral_path, persistent_path)
    else:
        seal_file(ephemeral_path, persistent_path)


def seal_directory(ephemeral_path, persistent_path):
    try:
        os.mkdir(persistent_path)
    except FileExistsError:
        pass
    for entry in os.listdir(ephemeral_path):
        new_persistent_path = os.path.join(persistent_path, entry)
        new_ephemeral_path = os.path.join(ephemeral_path, entry)

        # In Graphene chroots, for some reason files that were deleted are still being listed by os.listdir
        if not os.path.exists(new_ephemeral_path):
            continue

        seal_mapping(new_persistent_path, new_ephemeral_path)

    for entry in os.listdir(persistent_path):
        new_persistent_path = os.path.join(persistent_path, entry)
        new_ephemeral_path = os.path.join(ephemeral_path, entry)
        check_if_deleted(new_persistent_path, new_ephemeral_path)


def seal_file(ephemeral_path, persistent_path):
    logging.debug("sealing file %r", ephemeral_path)
    with open(ephemeral_path, 'br') as source:
        secret = source.read()

        logging.debug("secret: %r", secret)

        if secret:
            data = sealing.seal(secret)
        else:
            data = bytes()

        with open(persistent_path, 'bw') as dest:
            dest.write(data)


def check_if_deleted(persistent_path, ephemeral_path):
    if not os.path.exists(ephemeral_path):
        os.remove(persistent_path)


def test_append_to_file():
    path = '/tests/foo/bar'
    i = 0

    try:
        with open(path) as f:
            i = int(f.readlines()[-1])
    except FileNotFoundError:
        logging.info("Creating file %r" % path)
        create_empty(path)

    with open(path, 'a') as f:
        f.write("%s\n" % (i+1))


def main():
    logging.basicConfig(level=logging.DEBUG)

    with handle_sealing(MANIFEST_PATH):
        test_append_to_file()

        # XXX: For some reason the file modifications by the child are not synced with the parent,
        #      therefore the sealing doesn't work with child processes.
        # exit_code = os.spawnvp(os.P_WAIT, sys.argv[1], sys.argv[1:])
        # if exit_code != 0:
        #     logging.error("Command %r exited with code %r", " ".join(sys.argv[1:]), exit_code)


if __name__ == '__main__':
    # noinspection PyBroadException
    try:
        main()
    except:
        # Without this graphene's pal does not return on exceptions
        logging.exception('')
        exit()
