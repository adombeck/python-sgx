#!/usr/bin/env python3-sgx

import socketserver
import socket
import json
import logging
import argparse
import struct

from sgx.util import get_attester_public_key
from sgx.socket_util import receive_bytes

try:
    from sgx.trusted.attestation import RemoteAttestationContext
    from sgx.trusted.attestation import get_new_public_key
    from sgx.trusted.attestation import process_msg2
    from sgx.trusted.attestation import get_msg3
except:
    logging.exception("")
    exit()

ATTESTER_LT_PUBLIC_KEY = get_attester_public_key()

logging_handlers = list()

manager = None
ura_manager_port = None


class RequestHandler(socketserver.StreamRequestHandler):

    _request_num = 0

    def __init__(self, *args, **kwargs):
        self._request_num += 1
        self.id = self._request_num
        self.logger = logging.getLogger("Request#%s" % self.id)
        super(RequestHandler, self).__init__(*args, **kwargs)

    def handle(self):
        self.logger.info("Got request")

        client_socket = self.request

        request = receive_bytes(client_socket)

        if request == b"attest":
            self.perform_attestation(client_socket)

    def perform_attestation(self, client_socket: socket.socket):
        self.send_msg0(client_socket)

        with RemoteAttestationContext(attester_public_key=ATTESTER_LT_PUBLIC_KEY, use_pse=0) as ra_context:

            public_key = get_new_public_key(ra_context)

            self.send_msg1(client_socket, public_key)

            attester_public_key, spid, quote_type, kdf_id, key_signature, msg2_mac, revocation_list = \
                self.receive_msg2(client_socket)

            qe_target_info = self.initialize_quoting_enclave()

            self.logger.warning("revocation list: %r", revocation_list)

            report, nonce = process_msg2(ra_context,
                                         qe_target_info,
                                         attester_public_key,
                                         spid,
                                         quote_type,
                                         kdf_id,
                                         key_signature,
                                         msg2_mac,
                                         revocation_list)

            quote, qe_report = self.get_quote(report, quote_type, spid, nonce, revocation_list)
            msg3_mac, platform_service_security_properties = get_msg3(ra_context, quote, qe_report)

            self.send_msg3(client_socket, quote, msg3_mac, platform_service_security_properties)

            verification_result = self.receive_msg4(client_socket)

    # -------------------------------------------------------------------------
    # MSG0
    # -------------------------------------------------------------------------

    def send_msg0(self, client_socket: socket.socket):
        self.logger.info("Preparing to send msg0")

        epid = self.get_epid()

        msg0 = json.dumps({"EPID": epid}).encode()

        self.logger.info("Sending msg0")
        client_socket.sendall(msg0)

    def get_epid(self):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as ura_socket:
            ura_socket.connect(("127.0.0.1", ura_manager_port))

            self.send_epid_request(ura_socket)

            epid = self.receive_epid(ura_socket)

        return epid

    def send_epid_request(self, ura_socket: socket.socket):
        self.logger.info("Sending EPID request")

        msg = json.dumps({"request": "GET EPID"}).encode()

        ura_socket.sendall(msg)
        self.logger.info("EPID request sent")

    def receive_epid(self, ura_socket: socket.socket()):
        self.logger.info("Waiting for EPID")

        received_raw = receive_bytes(ura_socket)
        received_json = json.loads(received_raw.decode('utf8'))
        assert (isinstance(received_json, dict))
        assert (len(received_json) == 1)

        return received_json["EPID"]

    # -------------------------------------------------------------------------
    # MSG1
    # -------------------------------------------------------------------------

    def send_msg1(self, client_socket: socket.socket, public_key):
        self.logger.info("Preparing to send msg1")

        msg1 = json.dumps({"public_key": public_key.hex()}).encode()

        self.logger.info("Sending msg1")
        client_socket.sendall(msg1)

    # -------------------------------------------------------------------------
    # MSG2
    # -------------------------------------------------------------------------

    def initialize_quoting_enclave(self):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as ura_socket:
            ura_socket.connect(("127.0.0.1", ura_manager_port))
            self.send_qe_init_request(ura_socket)
            qe_target_info = self.receive_qe_target_info(ura_socket)

        return qe_target_info

    def send_qe_init_request(self, ura_socket: socket.socket):
        self.logger.info("Sending quoting enclave initialization request")

        msg = json.dumps({"request": "INIT QE"}).encode()

        ura_socket.sendall(msg)
        self.logger.info("Quoting enclave initialization request sent")

    def receive_qe_target_info(self, ura_socket: socket.socket()):
        self.logger.info("Waiting for quoting enclave target info")

        received_raw = receive_bytes(ura_socket)
        received_json = json.loads(received_raw.decode('utf8'))
        assert (isinstance(received_json, dict))
        assert (len(received_json) == 1)

        return bytes.fromhex(received_json["qe_target_info"])

    def receive_msg2(self, client_socket: socket.socket):
        self.logger.info("Waiting for msg2")

        received_raw = receive_bytes(client_socket)

        msg2 = json.loads(received_raw.decode('utf8'))
        assert (isinstance(msg2, dict))

        attester_public_key = bytes.fromhex(msg2["public_key"])
        spid = bytes.fromhex(msg2["spid"])
        quote_type = struct.unpack("H", bytes.fromhex(msg2["quote_type"]))[0]
        kdf_id = struct.unpack("H", bytes.fromhex(msg2["kdf_id"]))[0]
        key_signature = bytes.fromhex(msg2["key_signature"])
        mac = bytes.fromhex(msg2["mac"])
        revocation_list = bytes.fromhex(msg2["revocation_list"])

        return attester_public_key, spid, quote_type, kdf_id, key_signature, mac, revocation_list

    # -------------------------------------------------------------------------
    # MSG3
    # -------------------------------------------------------------------------

    def get_quote(self, report: bytes, quote_type: int, spid: bytes, nonce: bytes, revocation_list: bytes):
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as ura_socket:
            ura_socket.connect(("127.0.0.1", ura_manager_port))

            self.send_quote_request(ura_socket,
                                    report,
                                    quote_type,
                                    spid,
                                    nonce,
                                    revocation_list)

            return self.receive_quote(ura_socket)

    def send_msg3(self, client_socket: socket.socket, quote: bytes, mac: bytes, platform_service_security_properties: bytes):
        self.logger.info("Preparing to send msg3")

        msg3 = json.dumps({"quote": quote.hex(),
                           "mac": mac.hex(),
                           "platform_service_security_properties": platform_service_security_properties.hex()}).encode()

        client_socket.sendall(msg3)
        self.logger.info("Msg3 sent")

    def send_quote_request(self, ura_socket: socket.socket, report: bytes, quote_type: int, spid: bytes, nonce: bytes, revocation_list: bytes):

        msg = json.dumps({
            "request": "GET QUOTE",
            "report": report.hex(),
            "quote_type": quote_type,
            "spid": spid.hex(),
            "nonce": nonce.hex(),
            "revocation_list": revocation_list.hex()
        }).encode()

        self.logger.info("Sending quote request (message size: %s)", len(msg))
        ura_socket.sendall(msg)
        self.logger.info("Quote request sent")

    def receive_quote(self, ura_socket: socket.socket()):
        self.logger.info("Waiting for quote")

        received_raw = receive_bytes(ura_socket)
        received_json = json.loads(received_raw.decode('utf8'))
        assert (isinstance(received_json, dict))
        assert (len(received_json) == 2)

        return bytes.fromhex(received_json["quote"]), bytes.fromhex(received_json["qe_report"])

    # -------------------------------------------------------------------------
    # MSG4
    # -------------------------------------------------------------------------

    def receive_msg4(self, client_socket: socket.socket):
        self.logger.info("Waiting for msg4")
        received_raw = receive_bytes(client_socket)
        msg2 = json.loads(received_raw.decode('utf8'))
        assert (isinstance(msg2, dict))

        verification_result = msg2["verification_result"]

        return verification_result


class Manager(object):
    def __init__(self, interface, port):
        self.interface = interface
        self.port = port
        self.server = socketserver.TCPServer((interface, port), RequestHandler)
        self.server.handle_error = self.handle_error
        self.logger = logging.getLogger("Manager")

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.logger.info("Stopping server")
        self.server.server_close()

    def handle_error(self, request, client_address):
        self.logger.exception("Exception while handling request %r" % request)

    def run(self):
        self.logger.info("Listening for attestation requests on %s:%s", self.interface, self.port)
        self.server.serve_forever()


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--interface", "-i", default="127.0.0.1")
    parser.add_argument("--port", "-p", type=int, default=6789)
    parser.add_argument("--ura-port", type=int, default=9876, help="Port of the untrusted remote attestation manager")
    parser.add_argument("--verbose", "-v", action="store_true")
    return parser.parse_args()


def init(args):
    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    global ura_manager_port
    ura_manager_port = args.ura_port


def main():
    args = parse_args()
    init(args)

    global manager
    with Manager(args.interface, args.port) as manager:
        manager.run()


if __name__ == "__main__":
    try:
        main()
    except:
        # Without this graphene's pal does not return on exceptions
        logging.exception("")
        exit()
