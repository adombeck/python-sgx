%module $(NAME)_swig

%{
#define SWIG_PYTHON_STRICT_BYTE_CHAR
#include "sgx_tseal.h"
#include "sgx_key.h"
#include "sgx_error.h"
#include "sgx_defs.h"
#include "sgx_attributes.h"
#include "sgx_tcrypto.h"
#include "sgx.h"
#include "sgx_defs.h"
#include "sgx_report.h"

typedef uint32_t sgx_ra_context_t;

static void reverse_byte_array(uint8_t *array, size_t size)
{
    size_t i = 0;
    for(i = 0; i < size / 2; i++)
    {
        uint8_t temp = array[i];
        array[i] = array[size - i - 1];
        array[size - i - 1] = temp;
    }
}

extern void main();

extern void get_new_public_key(sgx_ra_context_t context, sgx_ec256_public_t** pp_enclave_public_key);
extern void initialize_remote_attestation(sgx_ec256_public_t enclave_public_key, int use_pse, sgx_ra_context_t* p_context);
%}

%include "cdata.i"
%include "stdint.i"
%include "typemaps.i"
%include "cstring.i"
%include "sgx_defs.h"

typedef uint32_t sgx_ra_context_t;


extern void main();


// ----------------------------------------------------------------------------
// map sgx_ec256_public_t to Python class with gx, gy as bytes objects
// ----------------------------------------------------------------------------

// Define input and output typemaps for gx

%typemap(in) uint8_t gx[32] {
    if (!PyBytes_Check($input)) {
        PyErr_SetString(PyExc_TypeError, "Expected a bytes parameter");
        SWIG_fail;
    }

    if (PyObject_Length($input) != 32) {
        PyErr_SetString(PyExc_ValueError, "Expected a bytes parameter with 32 elements");
        SWIG_fail;
    }

    uint8_t res[32];
    char* bytes = PyBytes_AsString($input);
    int i;
    for (i=0; i<32; i++) {
        res[i] = (uint8_t) bytes[i];
    }

    $1 = res;
}

%typemap(out) uint8_t gx[32] {
    $result = PyBytes_FromStringAndSize((char*) $1, 32);
}


// Reuse the gx typemaps for gy

%typemap(in) uint8_t gy[32] = uint8_t gx[32];
%typemap(out) uint8_t gy[32] = uint8_t gx[32];


// Define typemaps for enclave_public_key

%typemap(in) sgx_ec256_public_t enclave_public_key {
    if (!PyBytes_Check($input)) {
        PyErr_SetString(PyExc_TypeError, "Expected a bytes parameter");
        SWIG_fail;
    }

    if (PyObject_Length($input) != 64) {
        PyErr_SetString(PyExc_ValueError, "Expected a bytes parameter with 64 elements");
        SWIG_fail;
    }

    sgx_ec256_public_t res;
    char* bytes = PyBytes_AsString($input);
    int i;
    for (i=0; i<32; i++) {
        res.gx[i] = (uint8_t) bytes[i];
        res.gy[i] = (uint8_t) bytes[i+32];
    }

    // Reverse byte order to big-endian
    reverse_byte_array(res.gx, 32);
    reverse_byte_array(res.gy, 32);

    $1 = res;
}

%typemap(out) sgx_ec256_public_t enclave_public_key {
    uint8_t tmp[64];
    memcpy(&tmp[0], $1.gx, 32);
    memcpy(&tmp[32], $1.gy, 32);

    // Reverse byte order to big-endian
    reverse_byte_array(&tmp[0], 32);
    reverse_byte_array(&tmp[32], 32);

    $result = PyBytes_FromStringAndSize((char*) tmp, 64);
}


// Define typemaps for pp_enclave_public_key

// This typemap suppresses requiring the parameter as an input.
%typemap(in,numinputs=0) sgx_ec256_public_t** pp_enclave_public_key (sgx_ec256_public_t* temp) {
  $1 = &temp;
}

%typemap(argout) sgx_ec256_public_t** pp_enclave_public_key {
    #$result = SWIG_NewPointerObj(*$1, $descriptor(sgx_ec256_public_t*), SWIG_POINTER_OWN);
    uint8_t tmp[64];
    memcpy(&tmp[0], (*$1)->gx, 32);
    memcpy(&tmp[32], (*$1)->gy, 32);

    // Reverse byte order to big-endian
    reverse_byte_array(&tmp[0], 32);
    reverse_byte_array(&tmp[32], 32);

    $result = PyBytes_FromStringAndSize((char*) tmp, 64);
}


// Declare functions which use the public key typemaps

extern void get_new_public_key(sgx_ra_context_t context, sgx_ec256_public_t** pp_enclave_public_key);

%apply uint32_t* OUTPUT { sgx_ra_context_t* p_context };
extern void initialize_remote_attestation(sgx_ec256_public_t enclave_public_key, int use_pse, sgx_ra_context_t* p_context);

%include "sgx_tcrypto.h"

// ----------------------------------------------------------------------------